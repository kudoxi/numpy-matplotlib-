import numpy as np

'''
a = np.arange(1,7)
b = np.arange(7,13)
print(a,b)
print(np.add(a,b)) #[1 2 3 4 5 6] + [ 7  8  9 10 11 12]
print(np.add.reduce(a)) #a的累加和　1+2+3+4+5+6
print(np.add.accumulate(a)) # a的累加和的过程　[1 1+2 1+2+3 1+2+3+4 1+2+3+4+5　1+2+3+4+5+6] -> [ 1  3  6 10 15 21]
print(np.add.outer([10,20,30],a))#外和　
#１＋１０　２＋１０　３＋１０　４＋１０　５＋１０　６＋１０
#1+20 2+20 3+20 4+20 5+20 6+20
#1+30 2+30 3+30 4+30 5+30 6+30

a = np.array([20,20,-20,-20])
b = np.array([3,-3,6,-6])
print(np.prod(a)) #数组元素累乘
print(np.cumprod(a)) #数组元素累乘的过程
print(np.divide(a,b)) #和a/b相同　其他版本np.true_divide(a,b)
print(np.floor_divide(a,b))#求的结果向下取整
print(np.ceil(a/b)) #求的结果向上取整
print(np.trunc(a/b))#截断取整
print(np.round(a/b))#四舍五入


'''
#位运算通用函数
#位异或 可以判断两组数据是否为同号 不同返回１，同返回０
a = np.array([0,-1,2,-3,4,-5])
b = np.array([0,-1,2,3,4,5])
c = a ^ b
c = a.__xor__(b)
c = np.bitwise_xor(a,b)
print(c)#[ 0  0  0 -2  0 -2] 小于０，说明就是异号
print(np.where(c<0)) #(array([3, 5]),)给出元组，里面放着异号元素的下标
#　10^8
#　1010 10
#　1000 8
#-------
#　0010 2
'''

-8  1000
-7  1001
-6 1010
-5 1011
-4 1100
-3 1101
-2 1110
-1 1111
0  0000
1  0001
2  0010
3  0011
4  0100
5  0101
6  0110
7  0111

科学家提出，分一半给负数
1011  -5
+  1   1
1100->-4

 1111           -1
 +  1            1
10000　溢出1,变为 0


'''


#判断某个数，是否为２的幂
a = np.arange(1,100)
c = np.bitwise_and(a,(a-1))
print(a[c==0])
'''
1  00001     0   00000
2  00010     1   00001
4  00100     3   00011
8  01000     7   00111
16 10000     15  01111

n的２进制　＆　n-1的２进制如果为０，说明n是２的幂

'''